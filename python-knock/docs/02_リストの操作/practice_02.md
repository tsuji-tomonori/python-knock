# 問題(02B): ライフゲーム

> 生生流転: すべての物は絶えず生まれては変化し、移り変わっていくこと。

## 問題文

ライフゲーム（Game of Life）は、イギリスの数学者ジョン・コンウェイによって考案されたセル・オートマトンです。この問題では、ライフゲームの1ステップのシミュレーションを行う関数を実装してください。

ライフゲームの盤面は、`m × n` の二次元リストとして表現され、各セルは以下の2つの状態のいずれかを持ちます：
- **生存 (1)**: 細胞が生きている状態
- **死滅 (0)**: 細胞が死んでいる状態

各セルの次の世代の状態は、以下のルールに従って決定されます：
1. **生存しているセル (1)**:
   - 周囲の8マスに生存セルが **2つまたは3つ** ある場合、次の世代でも生存する。
   - それ以外の場合、過疎または過密により死滅する (0 になる)。
2. **死滅しているセル (0)**:
   - 周囲の8マスに生存セルが **ちょうど3つ** ある場合、新たに誕生する (1 になる)。
   - それ以外の場合、引き続き死滅する。

与えられた盤面 `board` の次の状態を計算する関数 `next_generation` を実装してください。


## 入力

```python
def next_generation(board: list[list[int]]) -> list[list[int]]:
    """
    ライフゲームの1ステップ分のシミュレーションを行い、次の世代の盤面を返す。

    Args:
        board (list[list[int]]): 現在の盤面（`m × n` の二次元リスト）

    Returns:
        list[list[int]]: 次の世代の盤面（`m × n` の二次元リスト）
    """
```

### 入力の制約
- `1 <= m, n <= 50` （盤面のサイズ）
- `board[i][j]` は `0` または `1` の値を取る
- `board` の外側には追加のセルは存在しない（境界を超える隣接セルは考慮しない）


## 出力
- 次の世代の盤面を `m × n` の二次元リストとして返す。

## サンプル1

#### 入力:
```python
def test_case_1():
    board = [
        [0, 1, 0],
        [0, 1, 1],
        [1, 0, 0]
    ]
    expected = [
        [0, 1, 1],
        [1, 0, 1],
        [0, 1, 0]
    ]
    assert next_generation(board) == expected
```

**解説**
- `(0,1) → 生存 (1)` のまま（周囲に2つの生存セル）
- `(1,1) → 死滅 (0)` に変化（周囲に1つの生存セルのみ）
- `(2,1) → 生存 (1)` に変化（周囲にちょうど3つの生存セル）

---

### サンプル2

```python
def test_case_2():
    board = [
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1]
    ]
    expected = [
        [1, 0, 1],
        [0, 0, 0],
        [1, 0, 1]
    ]
    assert next_generation(board) == expected
```

**解説**
- 過密のため `(1,1) → 0` になる（周囲に8つの生存セル）
- 周囲のセルも過密や誕生ルールに従い変化する
