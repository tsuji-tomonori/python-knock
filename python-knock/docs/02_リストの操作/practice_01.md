# 問題: ラングトンのアリ

### 問題

ラングトンのアリは、簡単なルールに従ってマス目を移動するセル・オートマトンの一種です。
以下のルールに従い、指定されたステップ数までアリを移動させた後のマス目の状態を求めてください。

#### **ルール**
1. アリは 2 次元の無限グリッド上におり、各マスは「白」または「黒」のいずれかである。
2. アリは「黒」のマスにいる場合、そのマスを「白」に変更し、**左に90度回転して** 1マス前進する。
3. アリは「白」のマスにいる場合、そのマスを「黒」に変更し、**右に90度回転して** 1マス前進する。
4. 指定されたステップ数まで移動を続ける。

グリッドの初期状態はすべて「白」とします。
アリの初期位置は `(0, 0)` で、**上向き（y軸正方向）** を向いています。
指定されたステップ数後のグリッドの状態を取得する関数を実装してください。

---

### **入力フォーマット**
以下の `simulate_langtons_ant` 関数を実装してください。

```python
from typing import List, Tuple

def simulate_langtons_ant(steps: int) -> List[Tuple[int, int]]:
    """
    ラングトンのアリを指定したステップ数移動させた後の黒いマスの座標を求める。

    Args:
        steps (int): アリが移動するステップ数 (0 <= steps <= 10_000)

    Returns:
        List[Tuple[int, int]]: 黒いマスの座標のリスト。各座標は (x, y) のタプル形式で返す。
    """
    ...
```

---

### **入力値の条件**
- `steps (int)`: `0 <= steps <= 10,000`
  - `steps = 0` の場合、グリッドの状態は初期状態のまま（すべて白）。

---

### **出力フォーマット**
- **黒いマスの座標のリスト** `List[Tuple[int, int]]`
  - 各要素は **(x座標, y座標)** のタプル。
  - 黒いマスが複数ある場合、座標を **昇順 (x, y) でソート** して返す。
  - 黒いマスがない場合は **空リスト `[]`** を返す。

---

### **サンプル**

#### **サンプル1**
```python
simulate_langtons_ant(steps=0)
```
**出力**
```python
[]
```
**解説**
- まだ移動していないため、黒いマスは存在しない。

---

#### **サンプル2**
```python
simulate_langtons_ant(steps=1)
```
**出力**
```python
[(0, 0)]
```
**解説**
- 初期位置 `(0, 0)` が白なので、黒に変更 → 右を向いて `(1, 0)` に移動。

---

#### **サンプル3**
```python
simulate_langtons_ant(steps=5)
```
**出力**
```python
[(-1, 0), (0, 0), (0, 1)]
```
**解説**
1. `(0, 0)`: 白 → 黒, **右向き** → `(1, 0)` に移動
2. `(1, 0)`: 白 → 黒, **下向き** → `(1, -1)` に移動
3. `(1, -1)`: 白 → 黒, **左向き** → `(0, -1)` に移動
4. `(0, -1)`: 白 → 黒, **上向き** → `(0, 0)` に移動
5. `(0, 0)`: 黒 → 白, **左向き** → `(-1, 0)` に移動

黒いマスは `(-1, 0), (0, 0), (0, 1)` の3つ。

---

#### **サンプル4**
```python
simulate_langtons_ant(steps=10)
```
**出力**
```python
[(-2, 0), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1)]
```
**解説**
- 10ステップ後に黒いマスの座標を昇順 `(x, y)` でソートして返す。

---

### **補足**
- グリッドは理論上無限に広がるため、リストの大きさに制約はない。
- `steps` が増えるとアリの軌道は複雑になるが、10,000ステップでも実行可能なように設計すること。
